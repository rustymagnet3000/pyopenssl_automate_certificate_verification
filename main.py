#!/usr/bin/python3
import time
from OpenSSL.SSL import (
    Connection,
    Error,
    WantReadError
)
from support.YDSocket import YDSocket
from socket import gaierror, timeout
from support.argparsing import parser
from support.Verifier import Verifier
from support.HostNameClean import HostNameCleaner
from support.CertCheck import CertificateChecker
from support.CertChainLList import SinglyLinkedList


def summary_print():
    if args.socket_info:
        YDSocket.print_all_connections()
    elif args.time:
        Verifier.print_time_to_handshake()
    elif args.all:
        YDSocket.print_all_connections()
        Verifier.print_time_to_handshake()
        for chain in Verifier.certificate_chains:
            chain.print_chain_details()
    else:
        YDSocket.print_all_connections()


if __name__ == '__main__':
    CertificateChecker.openssl_version()
    args = parser.parse_args()
    with args.hostnames_file as file:
        sanitized_hosts = HostNameCleaner(file)
    hosts = sanitized_hosts.hostnames

    verifier = Verifier(ca_dir=args.certs_path, c_rehash_loc=args.rehash_path)
    assert (verifier.cert_hash_count > 0)

    # Socket Table create
    for host in hosts:
        try:
            with YDSocket(host) as s:
                YDSocket.table.add_row([host, 'connected', s.sock.getpeername()])
                YDSocket.open_sockets.append(s.sock)
                tls_client = Connection(verifier.context, s.sock)
                tls_client.set_tlsext_host_name(bytes(s.host, 'utf-8'))  # Ensures ServerName when Verify() callbacks
                tls_client.set_connect_state()  # set to work in client mode
                cert_chain = SinglyLinkedList(s.host)
                Verifier.certificate_chains.append(cert_chain)
                tls_client.do_handshake()
                cert_chain.tls_version = tls_client.get_cipher_name()
                cert_chain.cipher_version = tls_client.get_cipher_version()
                new_cert_chain = tls_client.get_peer_cert_chain()
                cert_chain.end_time = time.time()
        except timeout:
            YDSocket.table.add_row([host, 'fail', 'timeout'])
            YDSocket.bad_sockets += 1
        except gaierror as e:
            YDSocket.table.add_row([host, 'fail', 'Socket.gaierror'])
            YDSocket.bad_sockets += 1
        except WantReadError:
            print("[!]WantReadError. Generated by non-blocking Socket")
        except Error as e:                                      # OpenSSL.SSL.Error
            print("[!]error with {0}\t{1}".format(s.host, e))
            pass                                                # pass: I already write the errors to a LinkedList
        except:
            YDSocket.table.add_row([host, 'fail', 'Socket error. unhandled'])
            YDSocket.bad_sockets += 1

summary_print()
